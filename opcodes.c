/*
 * opcodes.c
 *
 *  Created on: Mar 5, 2015
 *      Author: keyho_000
 */

#include "string.h"
#include "stdio.h"

#include "globals.h"
#include "utils.h"
#include "opcodes.h"
#include "constants.h"
#include "instructions.h"

//instruction id
//Opcode
//operand 1
//operand 2
int opcodes[][9] = {
		//Basic Instructions
		{ INS_AAA, 0x37, 0x00, 0x00, OP_NONE, OP_NONE, OP_NONE, OP_FLAGS_OPCODE_COUNT1, OP_FLAGS_NONE },
		{ INS_AAD, 0x00, 0x00, 0x00, OP_REG8, OP_REG8, OP_NONE, OP_FLAGS_OPCODE_COUNT1, OP_FLAGS_NONE },
		{ INS_AAM, 0x00, 0x00, 0x00, OP_REG8, OP_REG8, OP_NONE, OP_FLAGS_OPCODE_COUNT1, OP_FLAGS_NONE },
		{ INS_AAS, 0x00, 0x00, 0x00, OP_REG8, OP_REG8, OP_NONE, OP_FLAGS_OPCODE_COUNT1, OP_FLAGS_NONE },
		{ INS_ADC, 0x00, 0x00, 0x00, OP_REG8, OP_REG8, OP_NONE, OP_FLAGS_OPCODE_COUNT1, OP_FLAGS_NONE },

		{ INS_ADD, 0x00, 0x00, 0x00, OP_REG8 | OP_MEM8, OP_REG8, OP_NONE, OP_FLAGS_OPCODE_COUNT1 | OP_FLAGS_MODRM, OP_FLAGS_NONE },
		{ INS_ADD, 0x01, 0x00, 0x00, OP_REG16 | OP_MEM16, OP_REG16, OP_NONE, OP_FLAGS_OPCODE_COUNT1 | OP_FLAGS_16BIT | OP_FLAGS_MODRM, OP_FLAGS_NONE },
		{ INS_ADD, 0x01, 0x00, 0x00, OP_REG32 | OP_MEM32, OP_REG32, OP_NONE, OP_FLAGS_OPCODE_COUNT1 | OP_FLAGS_32BIT | OP_FLAGS_MODRM, OP_FLAGS_NONE },
		{ INS_ADD, 0x04, 0x00, 0x00, OP_AL, OP_IMM8, OP_NONE, OP_FLAGS_OPCODE_COUNT1, OP_FLAGS_NONE },
		/*{ INS_ADD, 0x05, 0x00, 0x00, OP_AX, OP_IMM8 | OP_IMM16, OP_NONE, OP_FLAGS_OPCODE_COUNT1 | OP_FLAGS_16BIT, OP_FLAGS_NONE },
		{ INS_ADD, 0x05, 0x00, 0x00, OP_EAX, OP_IMM8 | OP_IMM16 | OP_IMM32, OP_NONE, OP_FLAGS_OPCODE_COUNT1 | OP_FLAGS_32BIT, OP_FLAGS_NONE },
*/
		{ INS_ADD, 0x80, 0x00, 0x00, OP_REG8, OP_IMM8, OP_NONE, OP_FLAGS_OPCODE_COUNT1 | OP_FLAGS_MODRM_IMM, OP_FLAGS_NONE },
		{ INS_ADD, 0x83, 0x00, 0x00, OP_REG16, OP_IMM8, OP_NONE, OP_FLAGS_OPCODE_COUNT1 | OP_FLAGS_MODRM_IMM | OP_FLAGS_16BIT, OP_FLAGS_NONE },
		{ INS_ADD, 0x83, 0x00, 0x00, OP_REG32, OP_IMM8, OP_NONE, OP_FLAGS_OPCODE_COUNT1 | OP_FLAGS_MODRM_IMM | OP_FLAGS_32BIT, OP_FLAGS_NONE },
		{ INS_ADD, 0x81, 0x00, 0x00, OP_REG16, OP_IMM16, OP_NONE, OP_FLAGS_OPCODE_COUNT1 | OP_FLAGS_MODRM_IMM | OP_FLAGS_16BIT, OP_FLAGS_NONE },
		{ INS_ADD, 0x81, 0x00, 0x00, OP_REG32, OP_IMM32, OP_NONE, OP_FLAGS_OPCODE_COUNT1 | OP_FLAGS_MODRM_IMM | OP_FLAGS_32BIT, OP_FLAGS_NONE },

		{ INS_AND, 0x00, 0x00, 0x00, OP_REG8, OP_REG8, OP_NONE, OP_FLAGS_OPCODE_COUNT1, OP_FLAGS_NONE },
		{ INS_CALL, 0x00, 0x00, 0x00, OP_REG8, OP_REG8, OP_NONE, OP_FLAGS_OPCODE_COUNT1, OP_FLAGS_NONE },
		{ INS_CBW, 0x00, 0x00, 0x00, OP_REG8, OP_REG8, OP_NONE, OP_FLAGS_OPCODE_COUNT1, OP_FLAGS_NONE },
		{ INS_CLC, 0x00, 0x00, 0x00, OP_REG8, OP_REG8, OP_NONE, OP_FLAGS_OPCODE_COUNT1, OP_FLAGS_NONE },
		{ INS_CLD, 0x00, 0x00, 0x00, OP_REG8, OP_REG8, OP_NONE, OP_FLAGS_OPCODE_COUNT1, OP_FLAGS_NONE },
		{ INS_CLI, 0x00, 0x00, 0x00, OP_REG8, OP_REG8, OP_NONE, OP_FLAGS_OPCODE_COUNT1, OP_FLAGS_NONE },
		{ INS_CMC, 0x00, 0x00, 0x00, OP_REG8, OP_REG8, OP_NONE, OP_FLAGS_OPCODE_COUNT1, OP_FLAGS_NONE },
		{ INS_CMP, 0x00, 0x00, 0x00, OP_REG8, OP_REG8, OP_NONE, OP_FLAGS_OPCODE_COUNT1, OP_FLAGS_NONE },
		{ INS_CMPSB, 0x00, 0x00, 0x00, OP_REG8, OP_REG8, OP_NONE, OP_FLAGS_OPCODE_COUNT1, OP_FLAGS_NONE },
		{ INS_CMPSW, 0x00, 0x00, 0x00, OP_REG8, OP_REG8, OP_NONE, OP_FLAGS_OPCODE_COUNT1, OP_FLAGS_NONE },
		{ INS_CWD, 0x00, 0x00, 0x00, OP_REG8, OP_REG8, OP_NONE, OP_FLAGS_OPCODE_COUNT1, OP_FLAGS_NONE },
		{ INS_DAA, 0x00, 0x00, 0x00, OP_REG8, OP_REG8, OP_NONE, OP_FLAGS_OPCODE_COUNT1, OP_FLAGS_NONE },
		{ INS_DAS, 0x00, 0x00, 0x00, OP_REG8, OP_REG8, OP_NONE, OP_FLAGS_OPCODE_COUNT1, OP_FLAGS_NONE },
		{ INS_DEC, 0x00, 0x00, 0x00, OP_REG8, OP_REG8, OP_NONE, OP_FLAGS_OPCODE_COUNT1, OP_FLAGS_NONE },
		{ INS_DIV, 0x00, 0x00, 0x00, OP_REG8, OP_REG8, OP_NONE, OP_FLAGS_OPCODE_COUNT1, OP_FLAGS_NONE },
		{ INS_ESC, 0x00, 0x00, 0x00, OP_REG8, OP_REG8, OP_NONE, OP_FLAGS_OPCODE_COUNT1, OP_FLAGS_NONE },
		{ INS_HLT, 0x00, 0x00, 0x00, OP_REG8, OP_REG8, OP_NONE, OP_FLAGS_OPCODE_COUNT1, OP_FLAGS_NONE },
		{ INS_IDIV, 0x00, 0x00, 0x00, OP_REG8, OP_REG8, OP_NONE, OP_FLAGS_OPCODE_COUNT1, OP_FLAGS_NONE },
		{ INS_IMUL, 0x00, 0x00, 0x00, OP_REG8, OP_REG8, OP_NONE, OP_FLAGS_OPCODE_COUNT1, OP_FLAGS_NONE },
		{ INS_IN, 0x00, 0x00, 0x00, OP_REG8, OP_REG8, OP_NONE, OP_FLAGS_OPCODE_COUNT1, OP_FLAGS_NONE },
		{ INS_INC, 0x00, 0x00, 0x00, OP_REG8, OP_REG8, OP_NONE, OP_FLAGS_OPCODE_COUNT1, OP_FLAGS_NONE },
		{ INS_INT, 0x00, 0x00, 0x00, OP_REG8, OP_REG8, OP_NONE, OP_FLAGS_OPCODE_COUNT1, OP_FLAGS_NONE },
		{ INS_INTO, 0x00, 0x00, 0x00, OP_REG8, OP_REG8, OP_NONE, OP_FLAGS_OPCODE_COUNT1, OP_FLAGS_NONE },
		{ INS_IRET, 0x00, 0x00, 0x00, OP_REG8, OP_REG8, OP_NONE, OP_FLAGS_OPCODE_COUNT1, OP_FLAGS_NONE },
		{ INS_JCXZ, 0x00, 0x00, 0x00, OP_REG8, OP_REG8, OP_NONE, OP_FLAGS_OPCODE_COUNT1, OP_FLAGS_NONE },
		{ INS_JMP, 0x00, 0x00, 0x00, OP_REG8, OP_REG8, OP_NONE, OP_FLAGS_OPCODE_COUNT1, OP_FLAGS_NONE },
		{ INS_LAHF, 0x00, 0x00, 0x00, OP_REG8, OP_REG8, OP_NONE, OP_FLAGS_OPCODE_COUNT1, OP_FLAGS_NONE },
		{ INS_LDS, 0x00, 0x00, 0x00, OP_REG8, OP_REG8, OP_NONE, OP_FLAGS_OPCODE_COUNT1, OP_FLAGS_NONE },
		{ INS_LEA, 0x00, 0x00, 0x00, OP_REG8, OP_REG8, OP_NONE, OP_FLAGS_OPCODE_COUNT1, OP_FLAGS_NONE },
		{ INS_LES, 0x00, 0x00, 0x00, OP_REG8, OP_REG8, OP_NONE, OP_FLAGS_OPCODE_COUNT1, OP_FLAGS_NONE },
		{ INS_LOCK, 0x00, 0x00, 0x00, OP_REG8, OP_REG8, OP_NONE, OP_FLAGS_OPCODE_COUNT1, OP_FLAGS_NONE },
		{ INS_LODSB, 0x00, 0x00, 0x00, OP_REG8, OP_REG8, OP_NONE, OP_FLAGS_OPCODE_COUNT1, OP_FLAGS_NONE },
		{ INS_LODSW, 0x00, 0x00, 0x00, OP_REG8, OP_REG8, OP_NONE, OP_FLAGS_OPCODE_COUNT1, OP_FLAGS_NONE },
		{ INS_LOOP, 0x00, 0x00, 0x00, OP_REG8, OP_REG8, OP_NONE, OP_FLAGS_OPCODE_COUNT1, OP_FLAGS_NONE },
		{ INS_LOOPE, 0x00, 0x00, 0x00, OP_REG8, OP_REG8, OP_NONE, OP_FLAGS_OPCODE_COUNT1, OP_FLAGS_NONE },
		{ INS_LOOPNE, 0x00, 0x00, 0x00, OP_REG8, OP_REG8, OP_NONE, OP_FLAGS_OPCODE_COUNT1, OP_FLAGS_NONE },
		{ INS_LOOPNZ, 0x00, 0x00, 0x00, OP_REG8, OP_REG8, OP_NONE, OP_FLAGS_OPCODE_COUNT1, OP_FLAGS_NONE },
		{ INS_LOOPZ, 0x00, 0x00, 0x00, OP_REG8, OP_REG8, OP_NONE, OP_FLAGS_OPCODE_COUNT1, OP_FLAGS_NONE },

		{ INS_MOV, 0x88, 0x00, 0x00, OP_REG8 | OP_MEM8, OP_REG8, OP_NONE, OP_FLAGS_OPCODE_COUNT1 | OP_FLAGS_MODRM, OP_FLAGS_NONE },
		{ INS_MOV, 0x89, 0x00, 0x00, OP_REG16 | OP_MEM16, OP_REG16, OP_NONE, OP_FLAGS_OPCODE_COUNT1 | OP_FLAGS_16BIT | OP_FLAGS_MODRM, OP_FLAGS_NONE },
		{ INS_MOV, 0x89, 0x00, 0x00, OP_REG32 | OP_MEM32, OP_REG32, OP_NONE, OP_FLAGS_OPCODE_COUNT1 | OP_FLAGS_32BIT | OP_FLAGS_MODRM, OP_FLAGS_NONE },
		{ INS_MOV, 0x8A, 0x00, 0x00, OP_REG8, OP_REG8 | OP_MEM8, OP_NONE, OP_FLAGS_OPCODE_COUNT1 | OP_FLAGS_MODRM, OP_FLAGS_NONE },
		{ INS_MOV, 0x8B, 0x00, 0x00, OP_REG16, OP_REG16 | OP_MEM16, OP_NONE, OP_FLAGS_OPCODE_COUNT1 | OP_FLAGS_16BIT | OP_FLAGS_MODRM, OP_FLAGS_NONE },
		{ INS_MOV, 0x8B, 0x00, 0x00, OP_REG32, OP_REG32 | OP_MEM32, OP_NONE, OP_FLAGS_OPCODE_COUNT1 | OP_FLAGS_32BIT | OP_FLAGS_MODRM, OP_FLAGS_NONE },

		{ INS_MOV, 0xB0, 0x00, 0x00, OP_REG8, OP_IMM8, OP_NONE, OP_FLAGS_OPCODE_COUNT1 | OP_FLAGS_ADD_REG, OP_FLAGS_NONE },
		{ INS_MOV, 0xB8, 0x00, 0x00, OP_REG16, OP_IMM16, OP_NONE, OP_FLAGS_OPCODE_COUNT1 | OP_FLAGS_ADD_REG | OP_FLAGS_16BIT, OP_FLAGS_NONE },
		{ INS_MOV, 0xB8, 0x00, 0x00, OP_REG32, OP_IMM32, OP_NONE, OP_FLAGS_OPCODE_COUNT1 | OP_FLAGS_ADD_REG | OP_FLAGS_32BIT, OP_FLAGS_NONE },

		{ INS_MOVSB, 0x00, 0x00, 0x00, OP_REG8, OP_REG8, OP_NONE, OP_FLAGS_OPCODE_COUNT1, OP_FLAGS_NONE },
		{ INS_MOVSW, 0x00, 0x00, 0x00, OP_REG8, OP_REG8, OP_NONE, OP_FLAGS_OPCODE_COUNT1, OP_FLAGS_NONE },
		{ INS_MUL, 0x00, 0x00, 0x00, OP_REG8, OP_REG8, OP_NONE, OP_FLAGS_OPCODE_COUNT1, OP_FLAGS_NONE },
		{ INS_NEG, 0x00, 0x00, 0x00, OP_REG8, OP_REG8, OP_NONE, OP_FLAGS_OPCODE_COUNT1, OP_FLAGS_NONE },
		{ INS_NOP, 0x00, 0x00, 0x00, OP_REG8, OP_REG8, OP_NONE, OP_FLAGS_OPCODE_COUNT1, OP_FLAGS_NONE },
		{ INS_NOT, 0x00, 0x00, 0x00, OP_REG8, OP_REG8, OP_NONE, OP_FLAGS_OPCODE_COUNT1, OP_FLAGS_NONE },
		{ INS_OR, 0x00, 0x00, 0x00, OP_REG8, OP_REG8, OP_NONE, OP_FLAGS_OPCODE_COUNT1, OP_FLAGS_NONE },
		{ INS_OUT, 0x00, 0x00, 0x00, OP_REG8, OP_REG8, OP_NONE, OP_FLAGS_OPCODE_COUNT1, OP_FLAGS_NONE },
		{ INS_POP, 0x00, 0x00, 0x00, OP_REG8, OP_REG8, OP_NONE, OP_FLAGS_OPCODE_COUNT1, OP_FLAGS_NONE },
		{ INS_POPF, 0x00, 0x00, 0x00, OP_REG8, OP_REG8, OP_NONE, OP_FLAGS_OPCODE_COUNT1, OP_FLAGS_NONE },
		{ INS_PUSH, 0x00, 0x00, 0x00, OP_REG8, OP_REG8, OP_NONE, OP_FLAGS_OPCODE_COUNT1, OP_FLAGS_NONE },
		{ INS_PUSHF, 0x00, 0x00, 0x00, OP_REG8, OP_REG8, OP_NONE, OP_FLAGS_OPCODE_COUNT1, OP_FLAGS_NONE },
		{ INS_RCL, 0x00, 0x00, 0x00, OP_REG8, OP_REG8, OP_NONE, OP_FLAGS_OPCODE_COUNT1, OP_FLAGS_NONE },
		{ INS_RCR, 0x00, 0x00, 0x00, OP_REG8, OP_REG8, OP_NONE, OP_FLAGS_OPCODE_COUNT1, OP_FLAGS_NONE },
		{ INS_REP, 0x00, 0x00, 0x00, OP_REG8, OP_REG8, OP_NONE, OP_FLAGS_OPCODE_COUNT1, OP_FLAGS_NONE },
		{ INS_REPE, 0x00, 0x00, 0x00, OP_REG8, OP_REG8, OP_NONE, OP_FLAGS_OPCODE_COUNT1, OP_FLAGS_NONE },
		{ INS_REPNE, 0x00, 0x00, 0x00, OP_REG8, OP_REG8, OP_NONE, OP_FLAGS_OPCODE_COUNT1, OP_FLAGS_NONE },
		{ INS_REPNZ, 0x00, 0x00, 0x00, OP_REG8, OP_REG8, OP_NONE, OP_FLAGS_OPCODE_COUNT1, OP_FLAGS_NONE },
		{ INS_REPZ, 0x00, 0x00, 0x00, OP_REG8, OP_REG8, OP_NONE, OP_FLAGS_OPCODE_COUNT1, OP_FLAGS_NONE },
		{ INS_RET, 0x00, 0x00, 0x00, OP_REG8, OP_REG8, OP_NONE, OP_FLAGS_OPCODE_COUNT1, OP_FLAGS_NONE },
		{ INS_RETN, 0x00, 0x00, 0x00, OP_REG8, OP_REG8, OP_NONE, OP_FLAGS_OPCODE_COUNT1, OP_FLAGS_NONE },
		{ INS_RETF, 0x00, 0x00, 0x00, OP_REG8, OP_REG8, OP_NONE, OP_FLAGS_OPCODE_COUNT1, OP_FLAGS_NONE },
		{ INS_ROL, 0x00, 0x00, 0x00, OP_REG8, OP_REG8, OP_NONE, OP_FLAGS_OPCODE_COUNT1, OP_FLAGS_NONE },
		{ INS_ROR, 0x00, 0x00, 0x00, OP_REG8, OP_REG8, OP_NONE, OP_FLAGS_OPCODE_COUNT1, OP_FLAGS_NONE },
		{ INS_SAHF, 0x00, 0x00, 0x00, OP_REG8, OP_REG8, OP_NONE, OP_FLAGS_OPCODE_COUNT1, OP_FLAGS_NONE },
		{ INS_SAL, 0x00, 0x00, 0x00, OP_REG8, OP_REG8, OP_NONE, OP_FLAGS_OPCODE_COUNT1, OP_FLAGS_NONE },
		{ INS_SAR, 0x00, 0x00, 0x00, OP_REG8, OP_REG8, OP_NONE, OP_FLAGS_OPCODE_COUNT1, OP_FLAGS_NONE },
		{ INS_SBB, 0x00, 0x00, 0x00, OP_REG8, OP_REG8, OP_NONE, OP_FLAGS_OPCODE_COUNT1, OP_FLAGS_NONE },
		{ INS_SCASB, 0x00, 0x00, 0x00, OP_REG8, OP_REG8, OP_NONE, OP_FLAGS_OPCODE_COUNT1, OP_FLAGS_NONE },
		{ INS_SCASW, 0x00, 0x00, 0x00, OP_REG8, OP_REG8, OP_NONE, OP_FLAGS_OPCODE_COUNT1, OP_FLAGS_NONE },
		{ INS_SHL, 0x00, 0x00, 0x00, OP_REG8, OP_REG8, OP_NONE, OP_FLAGS_OPCODE_COUNT1, OP_FLAGS_NONE },
		{ INS_SHR, 0x00, 0x00, 0x00, OP_REG8, OP_REG8, OP_NONE, OP_FLAGS_OPCODE_COUNT1, OP_FLAGS_NONE },
		{ INS_STC, 0x00, 0x00, 0x00, OP_REG8, OP_REG8, OP_NONE, OP_FLAGS_OPCODE_COUNT1, OP_FLAGS_NONE },
		{ INS_STD, 0x00, 0x00, 0x00, OP_REG8, OP_REG8, OP_NONE, OP_FLAGS_OPCODE_COUNT1, OP_FLAGS_NONE },
		{ INS_STI, 0x00, 0x00, 0x00, OP_REG8, OP_REG8, OP_NONE, OP_FLAGS_OPCODE_COUNT1, OP_FLAGS_NONE },
		{ INS_STOSB, 0x00, 0x00, 0x00, OP_REG8, OP_REG8, OP_NONE, OP_FLAGS_OPCODE_COUNT1, OP_FLAGS_NONE },
		{ INS_STOSW, 0x00, 0x00, 0x00, OP_REG8, OP_REG8, OP_NONE, OP_FLAGS_OPCODE_COUNT1, OP_FLAGS_NONE },
		{ INS_SUB, 0x00, 0x00, 0x00, OP_REG8, OP_REG8, OP_NONE, OP_FLAGS_OPCODE_COUNT1, OP_FLAGS_NONE },
		{ INS_TEST, 0x00, 0x00, 0x00, OP_REG8, OP_REG8, OP_NONE, OP_FLAGS_OPCODE_COUNT1, OP_FLAGS_NONE },
		{ INS_WAIT, 0x00, 0x00, 0x00, OP_REG8, OP_REG8, OP_NONE, OP_FLAGS_OPCODE_COUNT1, OP_FLAGS_NONE },
		{ INS_XCHG, 0x00, 0x00, 0x00, OP_REG8, OP_REG8, OP_NONE, OP_FLAGS_OPCODE_COUNT1, OP_FLAGS_NONE },
		{ INS_XLAT, 0x00, 0x00, 0x00, OP_REG8, OP_REG8, OP_NONE, OP_FLAGS_OPCODE_COUNT1, OP_FLAGS_NONE },
		{ INS_XOR, 0x00, 0x00, 0x00, OP_REG8, OP_REG8, OP_NONE, OP_FLAGS_OPCODE_COUNT1, OP_FLAGS_NONE },
		{ INS_JA, 0x00, 0x00, 0x00, OP_REG8, OP_REG8, OP_NONE, OP_FLAGS_OPCODE_COUNT1, OP_FLAGS_NONE },
		{ INS_JAE, 0x00, 0x00, 0x00, OP_REG8, OP_REG8, OP_NONE, OP_FLAGS_OPCODE_COUNT1, OP_FLAGS_NONE },
		{ INS_JBE, 0x00, 0x00, 0x00, OP_REG8, OP_REG8, OP_NONE, OP_FLAGS_OPCODE_COUNT1, OP_FLAGS_NONE },
		{ INS_JBE, 0x00, 0x00, 0x00, OP_REG8, OP_REG8, OP_NONE, OP_FLAGS_OPCODE_COUNT1, OP_FLAGS_NONE },
		{ INS_JC, 0x00, 0x00, 0x00, OP_REG8, OP_REG8, OP_NONE, OP_FLAGS_OPCODE_COUNT1, OP_FLAGS_NONE },
		{ INS_JE, 0x00, 0x00, 0x00, OP_REG8, OP_REG8, OP_NONE, OP_FLAGS_OPCODE_COUNT1, OP_FLAGS_NONE },
		{ INS_JG, 0x00, 0x00, 0x00, OP_REG8, OP_REG8, OP_NONE, OP_FLAGS_OPCODE_COUNT1, OP_FLAGS_NONE },
		{ INS_JGE, 0x00, 0x00, 0x00, OP_REG8, OP_REG8, OP_NONE, OP_FLAGS_OPCODE_COUNT1, OP_FLAGS_NONE },
		{ INS_JL, 0x00, 0x00, 0x00, OP_REG8, OP_REG8, OP_NONE, OP_FLAGS_OPCODE_COUNT1, OP_FLAGS_NONE },
		{ INS_JLE, 0x00, 0x00, 0x00, OP_REG8, OP_REG8, OP_NONE, OP_FLAGS_OPCODE_COUNT1, OP_FLAGS_NONE },
		{ INS_JNA, 0x00, 0x00, 0x00, OP_REG8, OP_REG8, OP_NONE, OP_FLAGS_OPCODE_COUNT1, OP_FLAGS_NONE },
		{ INS_JNAE, 0x00, 0x00, 0x00, OP_REG8, OP_REG8, OP_NONE, OP_FLAGS_OPCODE_COUNT1, OP_FLAGS_NONE },
		{ INS_JNB, 0x00, 0x00, 0x00, OP_REG8, OP_REG8, OP_NONE, OP_FLAGS_OPCODE_COUNT1, OP_FLAGS_NONE },
		{ INS_JNBE, 0x00, 0x00, 0x00, OP_REG8, OP_REG8, OP_NONE, OP_FLAGS_OPCODE_COUNT1, OP_FLAGS_NONE },
		{ INS_JNC, 0x00, 0x00, 0x00, OP_REG8, OP_REG8, OP_NONE, OP_FLAGS_OPCODE_COUNT1, OP_FLAGS_NONE },
		{ INS_JNE, 0x00, 0x00, 0x00, OP_REG8, OP_REG8, OP_NONE, OP_FLAGS_OPCODE_COUNT1, OP_FLAGS_NONE },
		{ INS_JNG, 0x00, 0x00, 0x00, OP_REG8, OP_REG8, OP_NONE, OP_FLAGS_OPCODE_COUNT1, OP_FLAGS_NONE },
		{ INS_JNGE, 0x00, 0x00, 0x00, OP_REG8, OP_REG8, OP_NONE, OP_FLAGS_OPCODE_COUNT1, OP_FLAGS_NONE },
		{ INS_JNL, 0x00, 0x00, 0x00, OP_REG8, OP_REG8, OP_NONE, OP_FLAGS_OPCODE_COUNT1, OP_FLAGS_NONE },
		{ INS_JNLE, 0x00, 0x00, 0x00, OP_REG8, OP_REG8, OP_NONE, OP_FLAGS_OPCODE_COUNT1, OP_FLAGS_NONE },
		{ INS_JNO, 0x00, 0x00, 0x00, OP_REG8, OP_REG8, OP_NONE, OP_FLAGS_OPCODE_COUNT1, OP_FLAGS_NONE },
		{ INS_JNP, 0x00, 0x00, 0x00, OP_REG8, OP_REG8, OP_NONE, OP_FLAGS_OPCODE_COUNT1, OP_FLAGS_NONE },
		{ INS_JNS, 0x00, 0x00, 0x00, OP_REG8, OP_REG8, OP_NONE, OP_FLAGS_OPCODE_COUNT1, OP_FLAGS_NONE },
		{ INS_JNZ, 0x00, 0x00, 0x00, OP_REG8, OP_REG8, OP_NONE, OP_FLAGS_OPCODE_COUNT1, OP_FLAGS_NONE },
		{ INS_JO, 0x00, 0x00, 0x00, OP_REG8, OP_REG8, OP_NONE, OP_FLAGS_OPCODE_COUNT1, OP_FLAGS_NONE },
		{ INS_JP, 0x00, 0x00, 0x00, OP_REG8, OP_REG8, OP_NONE, OP_FLAGS_OPCODE_COUNT1, OP_FLAGS_NONE },
		{ INS_JPE, 0x00, 0x00, 0x00, OP_REG8, OP_REG8, OP_NONE, OP_FLAGS_OPCODE_COUNT1, OP_FLAGS_NONE },
		{ INS_JPO, 0x00, 0x00, 0x00, OP_REG8, OP_REG8, OP_NONE, OP_FLAGS_OPCODE_COUNT1, OP_FLAGS_NONE },
		{ INS_JS, 0x00, 0x00, 0x00, OP_REG8, OP_REG8, OP_NONE, OP_FLAGS_OPCODE_COUNT1, OP_FLAGS_NONE },
		{ INS_JZ, 0x00, 0x00, 0x00, OP_REG8, OP_REG8, OP_NONE, OP_FLAGS_OPCODE_COUNT1, OP_FLAGS_NONE },

		//Terminator
		{ INS_NOT_FOUND, 0x00, 0x00, 0x00, OP_NONE, OP_NONE, OP_NONE, OP_FLAGS_NONE, OP_FLAGS_NONE }
};

char* registers[][3] = {
		{ "AL", "AX", "EAX" },
		{ "CL", "CX", "ECX" },
		{ "DL", "DX", "EDX" },
		{ "BL", "BX", "EBX" },
		{ "AH", "SP", "SP" },
		{ "CH", "BP", "BP" },
		{ "DH", "SI", "SI" },
		{ "BH", "DI", "DI" },
};

/*
 int opcodes[OPCODE_TABLE_SIZE][6] = { { INS_ADD, 0x00, OP_REG8, OP_REG8, 0 }, {
 INS_ADD, 0x00, OP_MEM8, OP_REG8, 0 }, { INS_ADD, 0x02, OP_REG8, OP_REG8, 0 }, {
 INS_ADD, 0x02, OP_REG8, OP_MEM8, 0 }, { INS_ADD, 0x04, OP_IMM16,
 OP_IMM16, 0 } };
 */

char getModRMRegFromRegName(char* reg);

//Find the correct version of an opcode by its parameters
int* findOpcodeByOperands() {

	int index = 0;

	//Loop thru the entire opcode table, looking for the best possible opcode
	for (index = 0; opcodes[index][OPCODE_FLD_INS] != INS_NOT_FOUND; index++) {
		int* entry = opcodes[index];

		//If this entry is not for our instructions, then move on
		if (entry[OPCODE_FLD_INS] != context.currFile->insDesc->ins)
			continue;

		//compare params
		int param = 0;
		int invalidParams = 0;
		for (param = 0; param < 3; param++) {

			int availableOperand = entry[OPCODE_FLD_OPR1 + param];
			int providedOperand = context.currFile->insDesc->op[param].opType;

			if (availableOperand == OP_NONE) {
				break;
			}

			//If we didn't provide an operand  when one was required
			if (availableOperand != OP_NONE && providedOperand == OP_NONE) {
				invalidParams++;
				break;
			}
			//Or if it is not of a compatible type
			else if (!(availableOperand & providedOperand)) {
				invalidParams++;
				break;
			}
		}

		if (invalidParams < 1) {
			printf("FOUND A WINNER!\n");
			return entry;
		}

	}

	//Did not find any workable entry
	printf("Could not find an opcode to fit the params\n");
	return (int*) OP_NOT_FOUND;
}

int areCompatiableTypes(int availableOperand, int providedOperand) {
	//First check for a missing type/param
	if (availableOperand == OP_NONE && providedOperand == OP_NONE) {
		return TRUE;
	}

	return availableOperand & providedOperand;
}

void populateInstructionBytes() {
	INSTRUCTION* ins = context.currFile->insDesc;
	int* opcodeEntry = ins->opTableEntry;
	ins->byteArrayCount = 0;

	if (opcodeEntry == OP_NOT_FOUND) {
		return;
	}

	//Prefixes
	if (((opcodeEntry[OPCODE_FLD_FLG1] & OP_FLAGS_16BIT) && context.currFile->bitMode == CTX_BITS_32) ||
			((opcodeEntry[OPCODE_FLD_FLG1] & OP_FLAGS_32BIT) && context.currFile->bitMode == CTX_BITS_16)) {
		ins->byteArray[ins->byteArrayCount++] = OP_PREFIX_BIT_SIZE_SWITCH;
	}

	//Opcode(s)
	int i = 0;
	int opCount = (opcodeEntry[OPCODE_FLD_FLG1] & OP_FLAGS_MASK_OPCODE_COUNT) + 1; //Zero based, so increment by 1
	for (i = 0; i < opCount; i++) {

		//Do we add the register to the opcode?
		if (i == 0 && (opcodeEntry[OPCODE_FLD_FLG1] & OP_FLAGS_ADD_REG)) {
			int opc = (unsigned char) opcodeEntry[OPCODE_FLD_OPC1 + i];
			opc += getModRMRegFromRegName(ins->op[0].op);
			ins->byteArray[ins->byteArrayCount++] = opc;
		} else {
			ins->byteArray[ins->byteArrayCount++] = (unsigned char) opcodeEntry[OPCODE_FLD_OPC1 + i];
		}
	}

	//Modifier(s)
	if (opcodeEntry[OPCODE_FLD_FLG1] & OP_FLAGS_MODRM) {
		char mod = 0;
		char reg = 0;
		char rm = 0;

		//Are they both regs?
		if ((opcodeEntry[OPCODE_FLD_OPR1] & OP_REG_MASK) && (opcodeEntry[OPCODE_FLD_OPR2] & OP_REG_MASK)) {

			rm = getModRMRegFromRegName(ins->op[0].op);
			reg = getModRMRegFromRegName(ins->op[1].op) << 3;

			mod = MODRM_REG_REG | reg | rm;
		}/*
		//Reg to other
		else if (ins->op[0].opType & OP_REG_MASK) {
			mod = ins->op[0].opType;
		}
		//other to Reg
		else if (ins->op[1].opType & OP_REG_MASK) {
			mod = ins->op[1].opType;
		}*/

		ins->byteArray[ins->byteArrayCount++] = mod;
	} else if (opcodeEntry[OPCODE_FLD_FLG1] & OP_FLAGS_MODRM_IMM) { //MOD R/M for an instruction with an imediate operand is handled slightly different
		int reg = opcodeEntry[OPCODE_FLD_OPC2];
		int mod, rm;

		if(opcodeEntry[OPCODE_FLD_OPR1] & OP_REG_MASK) {
			mod = MODRM_REG_REG;
		}

		rm = getModRMRegFromRegName(ins->op[0].op);

		mod = MODRM_REG_REG | reg | rm;
		ins->byteArray[ins->byteArrayCount++] = mod;
	}

	//Immediate Values Operand 1
	for (i = 0; i < 3; i++) {
		int oper = opcodeEntry[OPCODE_FLD_OPR1 + i];
		if (oper & OP_IMM32) {
			ins->byteArray[ins->byteArrayCount++] = (ins->op[i].numberValue & 0xFF);
			ins->byteArray[ins->byteArrayCount++] = ((ins->op[i].numberValue >> 8) & 0xFF);
			ins->byteArray[ins->byteArrayCount++] = ((ins->op[i].numberValue >> 16) & 0xFF);
			ins->byteArray[ins->byteArrayCount++] = ((ins->op[i].numberValue >> 24) & 0xFF);
		} else if (oper & OP_IMM16) {
			ins->byteArray[ins->byteArrayCount++] = (ins->op[i].numberValue & 0xFF);
			ins->byteArray[ins->byteArrayCount++] = ((ins->op[i].numberValue >> 8) & 0xFF);
		} else if (oper & OP_IMM8) {
			ins->byteArray[ins->byteArrayCount++] = (ins->op[i].numberValue & 0xFF);
		}
	}
}

char getModRMRegFromRegName(char* reg) {
	char copy[MAX_TOKEN_SIZE];

	strcpy(copy, reg);
	strToUpper(copy);
	int r, b;

	for (r = 0; r < 8; r++) {
		for (b = 0; b < 3; b++) {
			if (!strcmp(copy, registers[r][b])) {
				return r;
			}
		}
	}

	return -1;
}
